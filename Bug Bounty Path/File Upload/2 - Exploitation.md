## Absent Validation
The most basic type of file upload vulnerability occurs when the web app **does not have any form of validation filters** on the uploaded files, allowing the upload of any file type by default.

With these types of vulnerable web apps, we may directly upload our **web shell** or **reverse shell** script to the web app, and then by just visiting the uploaded script, we can interact with our **web shell** or send the **reverse shell**.

Below we will see an **Employee File Manager** web app, which allows us to upload **personal files** to the web app: 
![[Attachments (images)/H1RWIDDEyg.png]]

The web app does not mention anything about what file types are allowed, and we can drag and drop any file we want, and its name will appear on the upload form, including **.php** files: 
![[Attachments (images)/rJWV8DPNyg.png]]

**Identifying Web Framework**
 A **web shell** has to be written in the **same** programming language that runs the **web server**, as it runs platform-specific functions and commands to execute system commands on the back-end server, making web shells non-cross-platform scripts. So, the **first step** would be to identify what language runs the web app.
  
One easy method to determine what language runs the web app is to visit the **/index.ext** page, where we would swap out **ext** with various common web extensions, like **php**, **asp**, **aspx**, among others, to see whether any of them exist.
 
Several other techniques may help identify the technologies running the web app, like using the **Wappalyzer** extension. Once added to our browser, we can click its icon to view all technologies running the web application: 
![[Attachments (images)/Sk_6DDwNJe.png]]

Not only did the extension tell us that the web application runs on **PHP**, but it also identified the **type** and **version** of the **web server**, the **back-end** operating system, and **other technologies** in use.

## Vulnerability Identification
Now that we have identified the **web framework** running the web app and its **programming language**, we can test whether we can upload a file with the same extension. As an initial test, we can upload arbitrary **PHP** files, let's create a basic **Hello World** script to test whether we can execute **PHP** code with our uploaded file.
To do so, we will write ```<?php echo "Hello HTB";?>``` to **test.php**, and try uploading it to the web application:
![[Attachments (images)/HkyYdwDNJe.png]]
we get a message saying File successfully uploaded, which means that the web application has **no** file validation whatsoever on the **back-end**. Now, we can click the **Download** button, and the web app will take us to our uploaded file: 
![[Attachments (images)/B1zh_PwVke.png]]

## Upload Exploitation
The final step in exploiting this web app is to upload the **malicious** script in the same language as the web app. Once we upload our **malicious** script and visit its link, we should be able to interact with it to take control over the back-end server.
## Web Shells
We can find many excellent **web shells** online that provide useful features, like directory traversal or file transfer. One good option for **PHP** is **phpbash**, which provides a terminal-like, semi-interactive **web shell**. Furthermore, SecLists provides a plethora of web shells for different frameworks and languages, which can be found in the **/opt/useful/seclists/Web-Shells** directory in a **PwnBox** (HTB).

We can download any of these web shells for the **language** of our web app, then upload it, and visit the uploaded file to interact with the **web shell**. For example, let's try to upload **phpbash.php** from **phpbash** to our web app:
![[Attachments (images)/rkg5bqPVJg.png]]
This web shell provides a **terminal**-like experience, which makes it very easy to **enumerate** the **back-end** server for further exploitation.

**Writing Custom Web Shell**

Although using **web shells** from online resources can provide a great experience, we should also know **how** to write a **simple web shell** manually. This is because we may **not** have access to online tools during some penetration tests.

For example, with **PHP** web apps, we can use the **system()** function that **executes** system commands and **prints** their output, and pass it the **cmd** parameter with ```$_REQUEST['cmd']```, as follows:
![[Attachments (images)/SJP-MqDNkg.png]]
If we write the above script to **shell.php** and upload it to our web app, we can execute **system** commands with the **?cmd=**, a **GET** parameter (e.g. **?cmd=id**), as follows: 
![[Attachments (images)/HkHsM9wVyl.png]]

Web shells are **not** exclusive to **PHP**, and the same applies to other web frameworks, with the only difference being the **functions** used to execute **system** commands. For **.NET** web apps, we can pass the **cmd** parameter with request(```'cmd'```) to the **eval()** function, and it should also execute the command specified in **?cmd=** and print its output, as follows:
![[Sk6b79vV1l.png]]

It **must** be noted that **in certain cases, web shells may not work**. This may be due to the web server **preventing** the use of some functions utilized by the web shell (e.g. **system()**), or due to a Web App Firewall, among other reasons. In these cases, we may need to use advanced techniques to **bypass** these security mitigations.

## Reverse Shell
Finally, let's see how we can receive **reverse shells** through the vulnerable upload functionality. We should start by downloading a **reverse shell** script in the language of the web app. One reliable **reverse shell** for **PHP** is the ([pentestmonkey PHP reverse shell](https://github.com/pentestmonkey/php-reverse-shell)). 
[SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) also contains various **reverse shell** scripts, and we can utilize any of them to receive a reverse shell as well.

Let's download pentestmonkey's reverse shell and then open it in a text editor to input our **IP** and **listening PORT**, which the script will connect to:
![[r1ag45DNJg.png]]

Next, we can start a **netcat** listener on our machine (with the above **port**), upload our script to the web app, and then visit its link to get a reverse shell connection:
![[B1E749v4ke.png]]

We **successfully** received a connection back from the **back-end** server that hosts the vulnerable web app. The same concept can be used for other web frameworks and languages, with the only **difference** being the reverse shell script we use.

## Generating Custom Reverse Shell Scripts
Just like web shells, we can also create our own reverse shell scripts. While it is possible to use the same previous **system** function and pass it a **reverse shell** command, this may not always be very reliable, as the command may fail for many reasons.

This is why it is always better to use core web framework functions to connect to our machine. However, this may not be as easy to memorize as a web shell script. Luckily, tools like **msfvenom** can **generate** a **reverse shell** script in many languages and may even attempt to **bypass** certain restrictions in place. We can do so as follows for **PHP**:
![[ByLhVcD4kg.png]]

Once our **reverse.php** script is generated, we once again start a **netcat** listener on the port we specified above, upload the **reverse.php** script and visit its link, and we should receive a reverse shell as well:
![[HJBkSqvEkl.png]]

Reverse shells may **not** always work, and we may have to rely on web shells instead. This can be for **several** reasons, like having a **firewall** on the **back-end** network that **prevents** outgoing connections or if the web server **disables** the necessary functions to initiate a connection back to us.
